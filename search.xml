<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八大排序算法之基数排序</title>
      <link href="/2016/07/23/radix-sort-algorithm/"/>
      <url>/2016/07/23/radix-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间Θ(n)。但桶排序并不是 比较排序，他不受到O(nlog<sub>2</sub>n)下限的影响。</p><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基数排序，len为数组长度，maxRadix为数组中数的最大位数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> maxRadix)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义二维辅助数组</span></span><br><span class="line">        <span class="type">int</span> temp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][len];</span><br><span class="line">        <span class="comment">// 当前排序的位数，初始状态为个位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 依次从个位数到最高位排序</span></span><br><span class="line">        &lt;!--more--&gt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; maxRadix; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据排序位上的数字放入二维数组，数字取值为0-9</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> (a[i] / partition) % <span class="number">10</span>;</span><br><span class="line">                temp[loc][i] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收集数组</span></span><br><span class="line">            CollectElement(a, temp);</span><br><span class="line">            <span class="comment">// 排序位数左移</span></span><br><span class="line">            partition = partition * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">CollectElement</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> temp[][])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; temp[<span class="number">0</span>].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果辅助数组中元素值大于零，将其加入数组</span></span><br><span class="line">                <span class="keyword">if</span> (temp[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                    a[index++] = temp[i][j];</span><br><span class="line">                <span class="comment">// 重置辅助数组</span></span><br><span class="line">                temp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left[], <span class="type">int</span> right[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 负数数组还原，并进行倒转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[index] = -left[i];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组中零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - left.length - right.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[index] = <span class="number">0</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入正数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[index] = right[i];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; -<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>, <span class="number">777</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">// 负数数组和正数数组</span></span><br><span class="line">        <span class="type">int</span> left[], right[];</span><br><span class="line">        <span class="comment">// 数组中负数和正数个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">negativeNum</span> <span class="operator">=</span> <span class="number">0</span>, positiveNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>)</span><br><span class="line">                negativeNum++;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>)</span><br><span class="line">                positiveNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化负数数组和正数数组</span></span><br><span class="line">        left = <span class="keyword">new</span> <span class="title class_">int</span>[negativeNum];</span><br><span class="line">        right = <span class="keyword">new</span> <span class="title class_">int</span>[positiveNum];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 负数数组赋值，并取其绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                left[j] = -a[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正数数组</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right[k] = a[i];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 负数数组基数排序</span></span><br><span class="line">        radixSort(left, left.length, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 正数数组基数排序</span></span><br><span class="line">        radixSort(right, right.length, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 将数组进行合并</span></span><br><span class="line">        mergeArray(a, left, right, len);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(d(r+n))<br>最好情况：O(d(n+rd))<br>最坏情况：O(d(r+n))</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(rd+n)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> radix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之归并排序</title>
      <link href="/2016/07/23/merge-sort-algorithm/"/>
      <url>/2016/07/23/merge-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取中间节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 左边部分归并排序</span></span><br><span class="line">            &lt;!--more--&gt;</span><br><span class="line">            mergeSort(a, left, mid);</span><br><span class="line">            <span class="comment">// 右边部分归并排序</span></span><br><span class="line">            mergeSort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">// 合并归并后的数组</span></span><br><span class="line">            merge(a, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">// 定义一个临时数组</span></span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left, i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 临时数组复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找出临时数组中左右部分中较小的元素赋给数组a</span></span><br><span class="line">            <span class="keyword">if</span> (temp[i] &lt; temp[j])</span><br><span class="line">                a[index++] = temp[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[index++] = temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果临时数组左边有剩余，则将剩余部分赋给数组a</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid)</span><br><span class="line">            a[index++] = temp[i++];</span><br><span class="line">        <span class="comment">// 如果临时数组右边有剩余，则将剩余部分赋给数组a</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= right)</span><br><span class="line">            a[index++] = temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行归并排序</span></span><br><span class="line">        mergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(nlog<sub>2</sub>n)<br>最好情况：O(nlog<sub>2</sub>n)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> merge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之快速排序</title>
      <link href="/2016/07/23/quick-sort-algorithm/"/>
      <url>/2016/07/23/quick-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ol><li>选择一个基准元素，通常选择第一个元素或者最后一个元素；</li><li>通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大；</li><li>此时基准元素在其排好序后的正确位置；</li><li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li></ol><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取数组中第left个元素在数组中的位置，将数组分为两部分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">            <span class="comment">// 左边部分进行排序</span></span><br><span class="line">            &lt;!--more--&gt;</span><br><span class="line">            quickSort(a, left, q - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 右边部分进行排序</span></span><br><span class="line">            quickSort(a, q + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录第left个元素的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从右边开始遍历数组，找到一个比pivot值小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; pivot &lt;= a[right])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="comment">// 将找到的元素值赋给第left个元素</span></span><br><span class="line">            a[left] = a[right];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从左边开始遍历数组，找到一个比pivot值大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; pivot &gt;= a[left])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">// 将找到的元素值赋给第right个元素</span></span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到第left个元素的位置并插入</span></span><br><span class="line">        a[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行快速排序</span></span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(nlog<sub>2</sub>n)<br>最好情况：O(nlog<sub>2</sub>n)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(nlog<sub>2</sub>n)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>不稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> quick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之冒泡排序</title>
      <link href="/2016/07/23/bubble-sort-algorithm/"/>
      <url>/2016/07/23/bubble-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            &lt;!--more--&gt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果后面元素比元素值小，则交换，每趟排序能找出一个较小元素</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 交换</span></span><br><span class="line">                    swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果一趟排序没有进行交换，表示数组已经有序，提前结束排序过程</span></span><br><span class="line">            <span class="keyword">if</span> (!flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换数组元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">777</span>, <span class="number">5550</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行冒泡排序</span></span><br><span class="line">        bubbleSort(a, a.length);</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(n<sup>2</sup>)<br>最好情况：O(n)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bubble </tag>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之选择排序</title>
      <link href="/2016/07/23/select-sort-algorithm/"/>
      <url>/2016/07/23/select-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第2个数）和第n个元素（最后一个数）比较为止。</p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ol><li>第一趟，从n个记录中找出关键码最小的记录与第1个记录交换；</li><li>第二趟，从第2个记录开始的n-1个记录中再选出关键码最小的记录与第2个记录交换；</li><li>以此类推…..</li><li>第i趟，则从第i个记录开始的n-i+1个记录中选出关键码最小的记录与第i 个记录交换，直到整个序列按关键码有序。</li></ol><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置最小元素为第i个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            &lt;!--more--&gt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果找到更小的元素，则重新设置最小元素序号</span></span><br><span class="line">                <span class="keyword">if</span> (a[min] &gt; a[j])</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将第i个元素与第min个元素交换</span></span><br><span class="line">            swap(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">777</span>, <span class="number">5550</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行选择排序</span></span><br><span class="line">        selectSort(a, a.length);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(n<sup>2</sup>)<br>最好情况：O(n<sup>2</sup>)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>不稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之堆排序</title>
      <link href="/2016/07/23/heap-sort-algorithm/"/>
      <url>/2016/07/23/heap-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>堆的定义如下：具有n个元素的序列（k<sub>1</sub>,k<sub>2</sub>,…,k<sub>n</sub>),当且仅当满足<br><img src="/img/heap-sort-algorithm.jpg"><br>时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于（或不小于）其子女的值，根结点（堆顶元素）的值是最小（或最大）的。</p><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 建立小根堆，即堆顶元素最小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从len/2依次到堆顶建立初始化小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            adjustDown(a, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!--more--&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustDown</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> index, <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录初始节点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[index];</span><br><span class="line">        <span class="comment">// 获取初始节点的子女节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果子女节点有兄弟节点，则取节点值更小的子女节点</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="comment">// 如果子女节点都比该节点值大，则结束调整</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; a[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 将子女节点的更小值赋给该节点</span></span><br><span class="line">            a[index] = a[i];</span><br><span class="line">            <span class="comment">// 设置改变的子女节点为新的初始节点</span></span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将初始节点值放入合适位置</span></span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立小根堆</span></span><br><span class="line">        buildMinHeap(a, len);</span><br><span class="line">        <span class="comment">// 打印堆顶元素</span></span><br><span class="line">        System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将堆顶元素与最后一个元素交换</span></span><br><span class="line">            swap(a, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 重新调整堆</span></span><br><span class="line">            adjustDown(a, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 打印调整后的堆顶元素</span></span><br><span class="line">            System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行堆排序</span></span><br><span class="line">        heapSort(a, a.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(nlog<sub>2</sub>n)<br>最好情况：O(nlog<sub>2</sub>n)<br>最坏情况：O(nlog<sub>2</sub>n)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>不稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之希尔排序</title>
      <link href="/2016/07/23/shell-sort-algorithm/"/>
      <url>/2016/07/23/shell-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ol><li>选择一个增量序列t<sub>1</sub>，t<sub>2</sub>，…，t<sub>k</sub>，其中t<sub>i</sub>&gt;t<sub>j</sub>，t<sub>k</sub>&#x3D;1；</li><li>按增量序列个数k，对序列进行k趟排序；</li><li>每趟排序，根据对应的增量t<sub>i</sub>，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 希尔插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellInsertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> dk)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dk; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果第i个元素比它前面的第dk个元素小</span></span><br><span class="line">            &lt;!--more--&gt;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i - dk])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="comment">// 记录第i个元素值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="comment">// 找到小于第i个元素值的位置，并将其前面元素后移</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j = j - dk)</span><br><span class="line">                    a[j + dk] = a[j];</span><br><span class="line">                <span class="comment">// 将第i个元素插入到找到的位置</span></span><br><span class="line">                a[j + dk] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 希尔排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始步长为len/2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dk</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (dk &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 步长大于1，进行希尔排序</span></span><br><span class="line">            shellInsertSort(a, len, dk);</span><br><span class="line">            <span class="comment">// 步长减半</span></span><br><span class="line">            dk = dk / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">777</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行希尔排序</span></span><br><span class="line">        shellSort(a, a.length);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(n<sup>1&#x2F;3</sup>)<br>最好情况：O(n)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>不稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法之直接插入排序</title>
      <link href="/2016/07/23/straight-insert-sort-algorithm/"/>
      <url>/2016/07/23/straight-insert-sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。<br>###要点<br>设立哨兵，作为临时存储和判断数组边界之用。</p><span id="more"></span><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StraightInsertSortAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果第i个元素比它前面的元素小</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="comment">// 记录第i个元素值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">                <span class="comment">// 找到小于第i个元素值的位置，并将其前面元素后移</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j--)</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                <span class="comment">// 将第i个元素插入到找到的位置</span></span><br><span class="line">                a[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义初始化数组</span></span><br><span class="line">        <span class="type">int</span> a[] =</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">777</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="comment">// 进行希尔排序</span></span><br><span class="line">        insertSort(a, a.length);</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        printArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均情况：O(n<sup>2</sup>)<br>最好情况：O(n)<br>最坏情况：O(n<sup>2</sup>)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> algorithm </tag>
            
            <tag> straightinsert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用git解决hexo博客多PC间同步问题</title>
      <link href="/2016/07/23/hexo-sync-in-multiple-pc/"/>
      <url>/2016/07/23/hexo-sync-in-multiple-pc/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文只是给类似我这样的git新人做参考，对git比较熟悉的话可以无视了。由于自身对git的了解就不是特别深，所以可能有些地方会有错误，欢迎各位指正。（本文有在微博上接受geekrainy的帮助，对此表示谢意)<br>ps：建议git相关操作都在bash上进行操作。不依赖windows下gui</p><span id="more"></span><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>单位和家里两PC，同时都想更新blog。而由于hexo没有后台，而且全部文件都在本地生成，所以如果公司电脑上发表了A文章后回家又写了篇B文章，在家里上传后你会发现只有B文章而A文章没了（因为家里的PC上没有A文章的md文件），所以多台电脑同时用来写文章的时候，需要解决备份问题。</p><p>而常用的备份方案无非两种：</p><h3 id="百度云，Dropbox等网盘云备份"><a href="#百度云，Dropbox等网盘云备份" class="headerlink" title="百度云，Dropbox等网盘云备份"></a>百度云，Dropbox等网盘云备份</h3><p>（不清楚Dropbox，仅以百度云为例）<br>优点：免费且操作简单<br>不足：</p><ol><li>备份后同步比较麻烦，每次另一台电脑上都需要手动下载备份文件夹手动覆盖。</li><li>开启云端自动备份的时候，写blog的过程中如果保存了文件，会触发百度云的上传，而上传过程中产生的<code>xxx.cfg</code>文件会让hexo解析失败，导致<code>hexo s</code>生成的本地服务器进程停止，不方便边写边预览</li></ol><p>因此此方案作废</p><h3 id="利用第三方的git服务备份"><a href="#利用第三方的git服务备份" class="headerlink" title="利用第三方的git服务备份"></a>利用第三方的git服务备份</h3><p>优点：部署完成后更新方便，hexo 更新完后只需要再更新全站到git即可<br>缺点：部署过程相对比较麻烦，对新手不友好（其实是由于对git的理解不深导致的）<br>国内外现在知名的git服务提供商主要有：<br>github、gitcafe、bitbucket、oschina、coding等</p><p>由于blog文件夹里有些插件配置文件会涉及比较敏感的隐私数据（云服务商的appsecret key之类的），所以建议放<strong>私有仓库</strong>（当然也可以把配置文件单独拿出来然后其余的全部扔到git的公众仓库，这个看人，本文重点也不在于git服务商的选择或者公有私有库之争）<br>上面提及的5家服务商里，<code>github</code>、<code>gitcafe</code>的私有库是收费的，而另外三家的私有库目前免费。各位可以自行选择，我个人选择了<a href="http://git.oschina.net/" title="oschina">oschina</a></p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>git多网站多账户部署过程可以参考<a href="http://chitanda.me/2015/06/11/tips-for-setup-hexo/#git%E5%A4%9A%E7%BD%91%E7%AB%99ssh%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88" title="git多网站ssh部署方案">git多网站ssh部署方案</a></p><h3 id="上传blog到git"><a href="#上传blog到git" class="headerlink" title="上传blog到git"></a>上传blog到git</h3><p>这个操作建议在blog进度最新的PC上进行的，否则后面解决冲突会比较麻烦<br>在osc上添加公钥，建立新respo等过程略过不讲。</p><ol><li><p>删除文件夹内原有的<code>.git</code>缓存文件夹并编辑<code>.gitignore</code>文件</p><blockquote><ul><li>有些插件或者主题是git上下过来安装的话，每个文件夹下都会有对应的.git 文件夹，记得先删掉，否则会和blog仓库冲突<br>（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。##.git文件夹被删除后整个文件对应的git仓库状态也会被清空##)</li></ul></blockquote><hr><blockquote><ul><li><code>.gitignore</code>文件作用是声明不被git记录的文件，blog根目录下的<code>.gitignore</code>是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议<code>.gitignore</code>内添加以下内容： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/.deploy_git</span><br><span class="line">/public</span><br><span class="line">/_config.yml</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>.deploy_git</code>是hexo默认的.git配置文件夹，不需要同步</li><li><code>public</code>内文件是根据<code>source</code>文件夹内容自动生成，不需要备份，不然每次改动内容太多</li><li>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</li></ol></blockquote></li><li><p>初始化仓库<br> blog根目录下执行以下代码：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;server&gt;</code>是指在线仓库的地址。<code>origin</code>是本地分支,<code>remote add</code>操作会将本地仓库映射到云端</p></blockquote></li><li><p>添加本地文件到仓库并同步到git上</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  <span class="comment">#添加blog目录下所有文件，注意有个`.`（`.gitignore`声明过的文件不包含在内)</span></span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span> <span class="comment">#添加更新说明</span></span><br><span class="line">git push -u origin master <span class="comment">#推送更新到云端服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>在执行这步之前一定要注意检查下<code>.gitignore</code>文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure><br>撤销添加操作。</p></blockquote></li></ol><p>到这里的时候，云端备份已经完成</p><h3 id="将git的内容同步到本地"><a href="#将git的内容同步到本地" class="headerlink" title="将git的内容同步到本地"></a>将git的内容同步到本地</h3><p>假设之前将A电脑里的内容备份到git了，现在B电脑准备同步内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;server&gt; <span class="comment">#将本地文件和云端仓库映射起来。这步不可以跳过</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><blockquote><p><code>fetch</code>是将云端所有内容拉取下来。<code>reset</code>则是不做任何合并处理，强制将本地内容指向刚刚同步下来的云端内容（正常pull的话需要考虑不少冲突的问题，比较麻烦。）</p></blockquote><h3 id="更新文章后的同步操作"><a href="#更新文章后的同步操作" class="headerlink" title="更新文章后的同步操作"></a>更新文章后的同步操作</h3><p>假设在B电脑上写完了文章，也<code>hexo d -g</code>发布完了，这时候需要将新文章的md文件更新上去。（其实就是提交更新给git，会的可以无视了）<br>同一个bash界面下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><blockquote><p>这时候可以用<code>git status</code>查看状态，一般会显示刚刚更改过的文件状态。如：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">    (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   db.json</span><br><span class="line">        new file:   <span class="built_in">source</span>/_posts/test.md</span><br></pre></td></tr></table></figure><blockquote><p>上面的输出状态即说明’db.json’文件做了更改，<code>source/_posts</code>目录下新增了’test.md’文件。</p></blockquote><p>然后对更改添加说明并推送到远程仓库.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;更新信息&#x27;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>当显示类似如下提示的时候，即表示备份成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To git@git.oschina.net:xxxx/blog-backup.git</span><br><span class="line"> + 2c77e1e...5616bc6 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><p>再到A电脑上的时候，只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>即可同步更新</p><h2 id="给git配置sock5代理"><a href="#给git配置sock5代理" class="headerlink" title="给git配置sock5代理"></a>给git配置sock5代理</h2><p>由于某些众所周知的缘故，所以github时不时的有时候速度会很慢，这种情况下本地代理就派上用场了。<br>这里以给git的SSH传输方式配置本地SS代理为例说下配置过程：</p><ol><li>打开<code>~/.ssh/config</code>文件。</li><li>在<code>Host github *.github.com</code>下添加以下字段： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxycommand ssh -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></li><li>测试连接<br>保存退出后重启git bash。<br>输入<code>ssh -vT git@github.com</code>，当返回<code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>的时候即说明配置成功<br>之后github的所有流量都会走本地的ss代理。</li></ol><p>转载于：<a href="http://chitanda.me/2015/06/18/hexo-sync-in-multiple-pc/" title="利用git解决hexo博客多PC间同步问题">http://chitanda.me/2015/06/18/hexo-sync-in-multiple-pc/</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> sync </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个充满好奇心的人，喜欢探索科技、文化和艺术的交汇点。本博客是我分享自己思考和学习成果的地方。</p><h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>这个博客是用 Hexo 搭建的，Hexo 是一个快速、简洁且高效的博客框架，基于 Node.js。我选择 Hexo 是因为它的简单易用性，让我可以专注于创作而不用过多关注技术细节。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email: <a href="mailto:&#121;&#111;&#110;&#107;&#101;&#x72;&#46;&#99;&#104;&#101;&#x75;&#110;&#x67;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#121;&#111;&#110;&#107;&#101;&#x72;&#46;&#99;&#104;&#101;&#x75;&#110;&#x67;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></li><li>Twitter: <a href="https://twitter.com/yonkercheung">@yonker.cheung</a></li><li>GitHub: <a href="https://github.com/yonker">yonker</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
